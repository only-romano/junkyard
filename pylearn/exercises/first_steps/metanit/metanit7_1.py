#! Работа с материалами Metanit, глава 7 "Объектно-ориентированное
# программирование", часть 1.  Классы и объекты.

# Класс является шаблоном или формальным описанием объекта, а объект
# представляет экземпляр этого класса, его реальное воплощение.  Можно
# провести следующую аналогию: есть некоторое представление о человеке
# - некоторый шаблон - этот шаблон можно назвать классом. Реально же
# существующий человек (фактически экземпляр данного класса) является
# объектом этого класса.

# С точки зрения кода класс объединяет набор функций и переменных,
#  которые выполняют определенную задачу.  Функции класса еще называют
# методами.  Они определяют поведение класса.  А переменные класса
# называют атрибутами - они хранят состояние класса.

# Класс определяется с помощью ключевого слова class:


class Person:
    name = "Tom"

    def display_info(self):
        print("Привет, меня зовут", self.name)


# Для создания объекта класса используется следующий синтаксис:
person1 = Person()
person1.display_info()          # Привет, меня зовут Tom.

person2 = Person()
person2.name = "Sam"
person2.display_info()          # Привет, меня зовут Sam.

# Класс Person определяет атрибут name, который хранит имя человека, и
# метод display_info, с помощью которого выводится информация.

# При определении методов любого класса следует учитывать, что все они
# должны принимать в качестве первого параметра ссылку на текущий
# объект, который согласно условностям называется self (в ряде языков
# программирования есть своего рода аналог - ключевое слово this).
# Через эту ссылку внутри класса мы можем обратиться к методам или
# атрибутам этого же класса.  В частности, через выражение self.name
# можно получить имя пользователя.

# После определения класс Person создаем пару его объектов - person1
# и person2.  Используя имя объекта, мы можем обратиться к его методам
# и атрибутам.  В данном случае у каждого из объектов вызываем метод
# display_info(), который выводит строку на консоль, и у второго объекта
# также изменяем атрибут name.  При этом при вызове метода display_info
# не надо передавать значение для параметра self.


# Конструкторы.

# Для создания объекта класса используется конструктор.  Так, выше когда
# мы создавали объекты класса Person, мы использовали конструктор по
# умолчанию, который неявно имеют все классы:
# person1 = Person()
# person2 = Person()

# Однако мы можем явным образом определить в классах конструктор с
# помощью специального метода, который называется __init().  К примеру,
# изменим класс Person, добавив в него конструктор:

class Mankind:

    # конструктор:
    def __init__(self, name):
        self.name = name        # Устанавливает имя.

    def display_civilization(self):
        print("Привет, ты создал цивилизацию:", self.name)


civilization1 = Mankind("Ацтеки")
civilization1.display_civilization()
civilization2 = Mankind("Шумеры")
civilization2.display_civilization()

# В качестве первого параметра конструктор также принимает ссылку на
# текущий объект - self.  Нередко в конструкторах устанавливаются
# атрибуты класса.  Так, в данном случае в качестве второго параметра
# в конструктор передается имя пользователя, которое устанавливается
# для атрибута self.name.  Причем для атрибута необязательно определять
# в классе переменную name, как это было в предыдущей версии класса
# Person.  Установка значения self.name = name уже неявно создает
# атрибут name.


# Определение классов в модулях и подключение.

# Как правило, классы размещаются в отдельных модулях и затем уже
# импортируются в основной скрипт программы.  Пусть у нас будет в
# проекте два файла: файл main.py (основной скрипт программы) и
# classes.py (скрипт с определением классов).

from classes_metanit7_1 import Witness, Auto

anna = Witness("Anna")
anna.display_witness()

bmw = Auto("BMW")
bmw.move(65)
