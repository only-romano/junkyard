public class Metanit2_3a{
    public static void main(String[] args){


// Логические операции над числами.


    // Логические операции над числами представляют поразрядные операции.
    // В данном случае числа рассматриваются в двоичном представлении,
    // например, 2 в двоичной системе равно 10 и имеет два разряда,
    // число 7 - 111 и имеет три разряда.

// & (логическое умножение)

    // Умножение производится поразрядно, и если у обоих операндов
    // значения разрядов равно 1, то операция возвращает 1, иначе
    // возвращается число 0. Например:

        int a1 = 2;  //010
        int b1 = 5;  //101
        System.out.println(a1&b1);  // результат 0

        int a2 = 4;  //100
        int b2 = 5;  //101
        System.out.println(a2 & b2);  // результат 4

    // В первом случае у нас два числа 2 и 5. 2 в двоичном виде
    // представляет число 010, а 5 - 101. Поразрядное умножение чисел
    // (0*1, 1*0, 0*1) дает результат 000.
    // Во втором случае у нас вместо двойки число 4, у которого в первом
    // разряде 1, так же как и у числа 5, поэтому здесь результатом
    // операции (1*1, 0*0, 0 *1) = 100 будет число 4 в десятичном формате.

// | (логическое сложение)

    // Данная операция также производится по двоичным разрядам, но
    // теперь возвращается единица, если хотя бы у одного числа в данном
    // разряде имеется единица (операция "логическое иЛи"). Например:

        System.out.println(a1|b1);  // результат 7 - 111
        System.out.println(a2 | b2); // результат 5 - 101

// ^ (логическое исключающее иЛи)

    // Также эту операцию называют XOR, нередко ее применяют для
    // простого шифрования:

        int number = 45;  // Значение, которое надо зашифровать -
                          // в двоичной форме 101101

        int key = 102;  //Ключ шифрования - в двоичной системе 1100110
        int encrypt = number ^ key;  //Результатом будет 1001011 или 75
        System.out.println("Зашифрованное число: " +encrypt);

        int decrypt = encrypt ^ key;  // Результатом будет исходное 45
        System.out.println("Расшифрованное число: " + decrypt);

    // Здесь также производятся поразрядные операции. Если у нас
    // значения текущего разряда у обоих чисел разные, то возвращается
    // 1, иначе возвращается 0. Например, результатом выражения 9^5
    // будет число 12. А чтобы расшифровать число, мы применяем обратную
    // операцию к результату.

// ~ (логическое отрицание)

    // Поразрядная операция, инвертирующая все разряды числа: если значение
    // разряда равно 1, то оно становится равным нулю, и наоборот.

        int a = 56; 
        System.out.println(~a);


// Операции сдвига


    // Операции сдвига также производятся над разрядами чисел. Сдвиг
    // может происходить вправо и влево.

// a<<b - сдвигает число a влево на b разрядов. Например:

        System.out.println(4<<1);

    // сдвигает число 4 (которое в двоичном представлении 100) на один
    // разряд влево, в результате получается число 1000 или число 8 в
    // десятичном представлении.

// a>>b - смещает число a вправо на b разрядов. Например,

        System.out.println(16>>1);

    // сдвигает число 16 (которое в двоичной системе 10000) на один
    // разряд вправо, то есть в итоге получается 1000 или число 8 в
    // десятичном представлении.

// a>>>b - в отличие от предыдущих типов сдвигов данная операция
// представляет беззнаковый сдвиг - сдвигает число a вправо на b
// разрядов. Например,

        System.out.println(8>>>2);  // будет равно 1073741822.

    // Таким образом, если исходное число, которое надо сдвинуть в ту
    // или другую строну, делится на два, то фактически получается
    // умножение или деление на два.  Поэтому подобную операцию можно
    // использовать вместо непосредственного умножения или деления на
    // два, так как операция сдвига на аппаратном уровне менее
    // дорогостоящая операция в отличие от операции деления или умножения.


// Операции сравнения


    // В операциях сравнения сравниваются два операнда, и возвращается
    // значение типа boolean - true, если выражение верно, и false,
    // если выражение неверно.

// == данная операция сравнивает два операнда на равенство: c=a==b;
//    c равно true, если a равно b, иначе c будет равно false.

// != c=a!=b; c равно true, если a не равно b, иначе false.

// <  c=a<b; c равно true, если a меньше b, иначе false.

// >  c=a>b; c равно true, если a больше b, иначе false.

// <= c=a<=b; c равно true, если a меньше или равно b, иначе false.

// >= c=a>=b; c равно true, если a больше или равно b, иначе false.


    // Кроме собственно операций сравнения в Java также определены
    // логические операторы, которые возвращают значение типа boolean.
    // Выше мы рассматривали поразрядные операции над числами. Теперь
    // же рассмотрим эти же операторы при операциях над булевыми
    // значениями:

// |  c=a|b; c равно true, если либо a, либо b (либо и a, и b) равны
//        true, иначе c будет равно false.

// &  c=a&b; c равно true, если и a, и b равны true, иначе false.

// |= c!=b; c равно true, если b равно false, иначе c равно false

// ^  c=a^b; c равно true, если либо a, либо b (но не одновременно)
//    равны true, иначе c будет равно false.

// || c=a||b; c равно true, если либо a, либо b (либо и a, и b) равны
//    true, иначе c будет равно false.

// && c=a&&b; c равно true, если и a, и b равны true, иначе c будет
//    равно false.


    // Здесь у нас две пары операций | и || (а также & и &&) выполняют
    // похожие действия, однако же они не равнозначны.

    // Выражение c=a|b; будет вычислять сначала оба значения - a и b и
    // на их основе выводить результат.

    // В выражении же c=a||b; вначале будет вычисляться значение a, и
    // если оно равно true, то вычисление значения b уже смысла не
    // имеет, так как у нас в любом случае уже c будет равно true.
    // Значение b будет вычисляться только в том случае, если a равно
    // false.

    // То же самое касается пары операций &/&&.  В выражении c=a&b;
    // будут вычисляться оба значения - a и b.

    // В выражении же c=a&&b; сначала будет вычисляться значение a, и
    // если оно равно false, то вычисление значения b уже не имеет
    // смысла, так как значение c в любом случае равно false. Значение
    // b будет вычисляться только в том случае, если a равно true.

    // Таким образом, операции || и && более удобны в вычислениях,
    // позволяя сократить время на вычисление значения выражения и
    // тем самым повышая производительность. А операции | и & больше
    // подходят для выполнения поразрядных операций над числами.

        boolean a3 = (5 > 6) || (4 < 6);
        // 5 > 6 - false, 4 < 6 - true, поэтому возвращается true
        System.out.println(a3);

        boolean a4 = (5 > 6) || (4 > 6);
        // 5 > 6 - false, 4 > 6 - false, поэтому возвращается false
        System.out.println(a4);

        boolean a5 = (5 > 6) && (4 < 6);
        // 5 > 6 - false, 4 < 6 - true, поэтому возвращается false
        System.out.println(a5);

        boolean a6 = (50 > 6) && (4 / 2 < 3);
        // 50 > 6 - true, 4/2 < 3 - true, поэтому возвращается true
        System.out.println(a6);

        boolean a7 = (5 > 6) ^ (4 < 6);
        // 5 > 6 - false, 4 < 6 - true, поэтому возвращается true
        System.out.println(a7);

        boolean a8 = (50 > 6) ^ (4 / 2 < 3);
        // 50 > 6 - true, 4/2 < 3 - true, поэтому возвращается false
        System.out.println(a8);


// Операции присваивания


// =  просто приравнивает одно значение другому: c=b;

// += c+=b; переменной c присваивается результат сложения c и b

// -= c-=b; переменной c присваивается результат вычитания b из c

// *= c*=b; переменной c присваивается результат произведения c и b

// /= c/=b; переменной c присваивается результат деления c на b

// %= c%=b; переменной c присваивается остаток от деления c на b

// &= c&=b; переменной c присваивается значение c&b

// |= c|=b; переменной c присваивается значение c|b

// ^= c^=b; переменной c присваивается значение c^b

// <<= c<<=b; переменной c присваивается значение c<<b

// >>= c>>=b; переменной c присваивается значение c>>b

// >>>= c>>>=b; переменной c присваивается значение c>>>b


// Приоритет операций


    // При работе с операциями важно понимать их приоритет, который
    // можно описать следующей таблицей.

    // Чем выше оператор в этой таблице, тем больше его приоритет. При
    // этом скобки повышают приоритет операции, используемой в выражении.

// expr++ expr--
// ++expr --expr +expr -expr ~ !
// * / %
// + -
// << >> >>>
// < > <= >= instanceof
// == !=
// &
// ^
// |
// &&
// ||
// ? : (тернарный оператор)
// = += -= *= /= %= &= ^= |= <<= >>= >>>= (операторы присваивания)

    //  Рассмотрим небольшой пример:

        int x = 4;
        int y = 5;
        int z = 100 + 10 * -20 / ++x * (y-1);

    // B этом случае будет выполняться выражение, результат которого
    // приравнивается переменной z:
        // 10*-20 (результат -200)
        // ++x (результат 5)
        // 10 * -20 /++x (результат -200 / 5 = -40)
        // (y -1) (результат 5 - 1 = 4)
        // 10 * -20 /++x * (y -1) (результат -40 * 4 = -160)
        // 100 + 10 * -20 /++x * (y -1) (результат 100 + -160 = -60)

        System.out.println(z);

    }
}