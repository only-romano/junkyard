#! Работа с материалами Metanit, глава 7, часть 2.  Инкапсуляция.

# По умолчанию атрибуты в классах являются общедоступными, а это значит,
# что из любого места программы мы можем получить атрибут объекта и
# изменить его.


class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def display_info(self):
        print("Имя:", self.name, "\tВозраст:", self.age)


tom = Person("Tom", 23)
tom.display_info()

tom.name = "Spider-man"
tom.age = -129
tom.display_info()


# С данной проблемой тесно связано понятие инкапсуляции.  Инкапсуляция
# является фундаментальной концепцией объектно-ориентированного
# программирования.  Она предотвращает прямой доступ к атрибутам объект
# из вызывающего кода.

# Касательно инкапсуляции непосредственно в языке программирования
# Python скрыть атрибуты класса можно сделав их приватными или закрытыми
# и ограничив доступ к ним через специальные методы, которые еще
# называются свойствами.


class Person2:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    # Для изменения возраста определено свойство:
    def set_age(self, age):
        if age in range(1, 133):
            self.__age = age
        else:
            print("Недопустимый возраст")
    # Здесь мы уже можем решить в зависимости от условий, надо ли
    # переустанавливать возраст.  Данный метод еще называют сеттер или
    # мьютейтор (mutator).

    # Нам может потребоваться устанавливать возраст пользователя из вне.
    # Для этого создаются свойства. Используя одно свойство, мы можем
    # получить значение атрибута:
    def get_age(self):
        return self.__age
    # Данный метод еще часто называют геттер или аксессор.

    # Необязательно создавать для каждого приватного атрибута пару
    # свойств.  Так, имя человека мы можем установить только из
    # конструктора.  А для получение определен метод get_name%
    def get_name(self):
        return self.__name

    def display_info(self):
        print("Имя:", self.__name, "\tВозраст:", self.__age)


tom = Person2("Tom", 23)

# Для создания приватного атрибута в начале его наименования ставится
# двойной прочерк: self.__name.  К такому атрибуту мы сможем обратиться
# только из того же класса.  Но не сможем обратиться вне этого класса.
# Например, присвоение значения этому атрибуту ничего не даст:
tom.__age = 43

# А попытка получить его значение приведет к ошибке выполнения:
# print(tom.__age)

tom.display_info()
tom.set_age(-3486)
tom.set_age(25)
tom.display_info()


# Аннотации свойств.

# Выше мы рассмотрели, как создавать свойства.  Но Python имеет также
# еще один - более элегантный способ определения свойств.  Этот способ
# предполагает использование аннотаций, которые предваряются символом @.


class Person3:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    # Для создания свойства-геттера над свойством ставится
    # аннотация @property:
    @property
    def age(self):
        return self.__age
    #

    # Для создания свойства-сеттера над свойством устанавливается
    # аннотация.  И сеттер, и геттер называются одинаково - age.  И
    # поскольку геттер называется age, то над сеттером устанавливается
    # аннотация @age.setter:
    @age.setter
    def age(self, age):
        if age in range(1, 100):
            self.__age = age
        else:
            print("Недопустимый возраст")
    # Cтоит обратить внимание, что свойство-сеттер определяется после
    # свойства-геттера.  После этого, что к геттеру, что к сеттеру, мы
    # обращаемся через выражение tom.age.

    @property
    def name(self):
        return self.__name

    def display_info(self):
        print("Имя:", self.__name, "\tВозраст:", self.__age)


tom = Person3("Tom", 23)

tom.display_info()
tom.age = -3476
print(tom.age)

tom.age = 36
tom.display_info()
