#! Работа с материалами Metanit, глава 3, часть 3. Словари.

# Синтаксис - dictionary = {ключ1: значение1, ключ2; значение2, ...)

users = {1: "Tom", 2: "Bob", 3: "Bill"}

elements = {"Au": "Gold", "Fe": "Iron", "H": "Hyprogen", "O": "Oxygen"}
print(users, "\n", elements)

objects = {}        # Пустой словарь.  objects = dict()  Альтернатива.
objects = {1: "Tom", "2": True, 3: 100.6}           # Смешанный тип.

# Отдельные виды списков можно преобразовать в словарь с помощью функции
# "diсt()".  Для этого список должен хранить набор вложенных списков.
# Каждый вложенный списко должен состоять из двух элементов, при
# конвертации в словарь первый элемент становится ключом, а второй
# значением.  Таким же образом можно преобразовать в словарь двухмерные
# кортежи, которые в свою очередь содержат кортежи из двух элементов:

users_list = [
    ["+111123455", "Tom"],
    ["+384767557", "Bob"],
    ["+958758767", "Alice"]
]
users_dict = dict(users_list)
print(users_dict)

users_tuple = tuple(users_list)
users_dict = dict(users_tuple)


# Получение и изменение элементов.

# Для доступа к элементам словаря используется ключ - dictionary[ключ].

# ВОПРОС : ТО ЕСТЬ В БИБЛИОТЕКЕ НА ДОСТАТЬ ЭЛЕМЕНТ ПО ПРИМЕРУ СПИСКОВ
# ИЛИ КОРТЕЖЕЙ - ИНДЕКСОМ ? ЗДЕСЬ ИСКЛЮЧИТЕЛЬНО ПО КЛЮЧУ?

print(users_dict["+111123455"])     # Tom

users_dict["+333333333"] = "Bob Smith"  # Добавлени элемента с ключом.
users_dict["+384767557"] = "Sam"        # Изменение элемента.
print(users_dict)

# user = users["+444444"] - Если ключа нет в словаре, ошибка KeyError.
# Для избежания такой ошибки используется конс-ция "if .. in ..":

if "+444444" in users_dict:
    print(users_dict["+444444"])
else:
    print("Элемент не найден")


# Для получения элементов можно использовать метод ".get()", который
# имеет форму .get(ключ) / .get(ключ, значение по умолчанию), т.е.:

key = "+958758767"
key2 = "+55555555"
user = users_dict.get(key)  # Генерирует KeyError если ключ отсутствует.
print(user)
user = users_dict.get(key2, "Unkbown User")
print(user)


# Для удаления элементов по ключу применяется оператор "del", во
# избежание ошибки KeyError желательно применять конструкцию:

if "+333333333" in users_dict:
    del users_dict["+333333333"]
    print(users_dict)
else:
    print("Элемент не найден")

# Альтернативный метод ".pop(ключ) / .pop(ключ, значение по умолчанию)":

user2 = users_dict.pop(key)
print(user2)

user3 = users_dict.pop(key2, "Unknown user")

# Удаление всех элементов:

users_dict.clear()


# Копирование и объединение словарей.

# Копирование методом ".copy()" возвращает новый словарь, копию первого:
users = {"+1111": "Tom", "+3333": "Bob", "+5555": "Alice"}
users2 = users.copy()
print(users2)

# Метод "словарь1.update(словарь2)" объединяет два словаря, при этом
# словарь2 остаётся без изменений.  Изменяется словарь1, в который
# добавляются элементы словарь2.  Если же надо, чтобы оба словаря
# остались без изменений, то тможно предварительно скопировать один
# из словарей в третий и в него уже объединять другой:

users = {"+1111": "Tom", "+3333": "Bob", "+5555": "Alice"}
users2 = {"+2222": "Sam", "+6666": "Kate"}
users3 = users.copy()
users3.update(users2)

print(users2)
print(users3)


# Перебор словаря.

# С помощью цикла for .. in ..:
for key in users3:      # При переборе получаем ключ элемента, а по нему
    print(key, " - ", users3[key])    # уже сам элемент.

# С помощью метода .items(), он возвращает набор кортежей:
for key, value in users3.items():     # Тоже для меня новое, что можно в
    print(key, " - ", value)          # этом цикле 2 просить у users3.

# .keys() и .values() позволяют перебрать ключи и значения отдельно:
for key in users3.keys():
    print(key)

for value in users3.values():
    print(value)


# Комплексные словари.

# Словари могут хранить в себе списки, кортежи или другие словари:
users = {
    "Tom": {
        "phone": "+971478745",
        "email": "tom12@gmail.com"
    },
    "Bob": {
        "phone": "+87690444",
        "email": "bob@gmail.com",
        "skype": "bob123"
    }
}

# Для обращения к элементам вложенного словаря используются два ключа:
old_email = users["Tom"]["email"]
users["Tom"]["email"] = "suppertom#gmail.com"

# tom_skype = users["Tom"]["skype"]     KeyError - ключ отсутствует.
# Для избежания этой ошибки:
if "skype" in users["Tom"]:
    print(users["Tom"]["skype"])
else:
    print("Skype is not found")
