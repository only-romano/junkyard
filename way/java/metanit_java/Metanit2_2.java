public class Metanit2_2 {

    public static void main(String[] args){

        byte x = 5;
        int y = x;  /// Происходит преобразование типа byte в int.
        System.out.println("x = y = " + y);

    // Кроме расширяющих преобразований есть еще и сужающие, например, от типа int,
    // который занимает 4 байта в памяти, к типу byte, который занимает только 1 байт
    // в памяти:
        int a = 4;
        byte b = (byte) a;
        System.out.println("a = b = " + b);

// Потеря данных при преобразовании.

    // В предыдущей ситуации число 4 вполне укладывалось в диапазон значений типа byte.
    // Но что будет в следующем случае:
        int c = 200;
        byte d = (byte) c;
        System.out.println("c = " + c + "\td = " + d);

    // Результатом будет число -56. В данном случае число 200 вне диапазона для типа byte
    // (от -128 до 127), поэтому произойдет усечение значения. Так как тип byte предполагает
    // 256 возможных значений, то полученное значение будет равно 200-256, то есть -56.

// Усечение рациональных чисел до целых

    // При преобразовании значений с плавающей точкой к целочисленным значениям, происходит
    // усечение дробной части:
        double e = 56.9898;
        int f = (int)e;
        System.out.println("e = " + e + "\tf = " + f);

    // Здесь значение числа b будет равно 56, несмотря на то, что число 57 было бы ближе к
    // 56.9898. Чтобы избежать подобных казусов, надо применять функцию округления, которая
    // есть в математической библиотеке Java:
        double g = 56.9898;
        int h = (int)Math.round(g);
        System.out.println("g = " + g + "\th = " + h);

// Преобразования при операциях

    // Нередки ситуации, когда приходится применять различные операции, например, сложение
    // и произведение, над значениями разных типов. Здесь также действуют некоторые правила:
    // - если один из операндов операции относится к типу double, то и второй операнд
    //   преобразуется к типу double
    // - если предыдущее условие не соблюдено, а один из операндов операции относится к типу
    //   float, то и второй операнд преобразуется к типу float
    // - если предыдущие условия не соблюдены, один из операндов операции относится к типу
    //   long, то и второй операнд преобразуется к типу long
    // - иначе все операнды операции преобразуются к типу int
        int i = 3;
        double j = 4.6;
        double k = i+j;
        System.out.println("i = " + i + "\tj = " + j + "\tk = " + k);

    // Так как в операции участвует значение типа double, то и другое значение приводится к
    // типу double и сумма двух значений a+b будет представлять тип double.  Другой пример:
        byte l = 3;
        short m = 4;
        byte n = (byte)(l+m);
        System.out.println("l = " + l + "\tm = " + m + "\tn = " + n);

    // Две переменных типа byte и short (не double, float или long), поэтому при сложении
    // они преобразуются к типу int, и их сумма a+b представляет значение типа int.
    // Поэтому если затем мы присваиваем эту сумму переменной типа byte, то нам опять надо
    // сделать преобразование типов к byte.

    }
}
