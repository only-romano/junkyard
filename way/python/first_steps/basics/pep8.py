#! Pep8. Код читается намного больше раз, чем пишется.
foo=long_function_name(var1, var2,#Вертикальный отступ, аргументы на
#первой линии запрещены, если не используется вертикальное выравнивание.
                       var3, var4)#Выровнено по открывающему разделителю
    #4 пробела на каждый уровень отступа.
def long_function_name(#Висячий отступ
        var1, var2, var3#больше отступов для отличения его от остальных
  #var1, var2, var3 - опциональный допустимый вариант = 2 пробела.
  #var3):#длину строки ограичить максимум 79 символами
        var4):#комментарии и документацию ограничить 72 символами
    print(var1)#ограничение длины строки позволяет иметь несколько
#открытых файлов; "-t" параметр в Python 2, который даст предупреждения
my_list = [#при использовании смешенного стиля в отступах - таб\пробелы
    1, 2, 3#"-tt" выдаст ошибки в этих местах смешенного стиля
    4, 5, 6#скобки ставятся под первым непробельным символом последней
    ]#строки списка
#]либо без отступа, под первом символом конструкции
#для переноса строк предпочтительнее использовать продолжений в скобках
with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())#косая черта допустима в конструкциях,
#где не может быть использовано неявное продолжение, пример - with
#!Что такое assert ?
class Rectangle(Blob):#отделять функции верхнего уровня и определения
#классов двумя пустыми строками; определения методов разделять одной
#разделять различные группы похожих функций. можно без пустых для
    def __init__(self, width, height,#связанных однострочников
                 color='black', emphasis=None, highlight=0):
        if (width == 0 and height == 0 and#перенос вставить после логи-
                color == 'red' and emphasis == 'strong' or#ческого опе-
                highlight > 100):#ратора, а не перед ним
            raise ValueError("sorry, you lose")#(ctrl+L у меня не сра-
        if width == 0 and height == 0 and (color == 'red' or#ботало)
                                           emphasis is None):
            raise ValueError("I don't think so -- values are %s, %s" %
                             (width, height))#что такое %s ?
        Blob.__init__(self, width, height,#в функции пустые строки ука-
                      color, emphasis, highlight)#жут логические разделы
#кодировка - UTF-8 (Python 3), ASCII(Python 2) без объявления кодировки
#"\x, \u, \U, \N" - предпочтительный способ включить не ASCII символы
#идентфикаторы обязаны означать английские слова везде, где возможно
import os#каждый импорт должен быть на отдельной строке (чё за импорты?)
import sys#импорты помещаются в начале файла после комментариев к моду-
#лю и документации и перед константами. 1 - из стандартной библиотеки;
#2 - из сторонних библиотек; 3 - из модулей текущего проекта.
from subprocess import Popen, PIPE#приемлимый вариант
#вставлять пустую строку между каждой группой импортов; сертификации
#указывать после импортов
import mypkh.sibling#рекомендуется абсолютное импортирование, оно ве-
from mypkh import sibling#дёт себя лучше если система настроена непра-
from mypkh.sibling import example#вильно. Вот тут ничего не поняла :((
#шаблоны импортов (from import *) следует избегать - путаница глоб.имён
from . import sibling#Явный относительный импорт приемлимая альтернатива
from .sibling import example#эти точечки - это что, пути пропускаемые ?

from myclass import MyClass#когда импортируем класс из модуля, можно так
from foo.bar.yourclass import YourClass#снова ничего не поняла :((

import myclass#использовать myclass.MyClass, foo.bar.yourclass.YourClass
import foo.bar.yourclass#тоже хз чёйта...
#пробелы в ввыражениях и инструкциях
spam(ham[1], {eggs: 2})#правиьно \ ( ham[1], {eggs: 2} ) - неправильно
if x ==4: print(x, y); x, y = y, x#а что, в одну строку можно писать?
#неправильно - if x == 4 : print(x, y) ; x , y = y , x - после знаков
spam(1)#правиьно \ spam (1) - неправильно
dict['key'] = list[index]#правиьно \ dict ['key'] = list [index] - нет
#не выравнивать пробелами операторов присваивания (или других)
x = 1#                            x =             1
y = 2#правиьно \ неправильно :    y =             2
long_variable = 3#                long_variable = 3
#всегда окружать эти бинарные операторы одним пробелом с каждой стороны:
#присваивание (=, +=, -= и т.д.), сравнение (==, <, >, !=, <>, <=, >=,
#in, not in, is, os not), логические (and, or, not)
i = i + 1#если разные приоритеты, то опустить     i=i+1
submitted += 1#пробел у первейшего действия       submitted +=1
x = x*2 - 1#        правильно   \   не правильно  x = x * 2 - 1
hypot2 = x*x + y*y#                               hypot2 = x * x + y * y
c = (a+b) * (a-b)#                                c = (a + b) * (a - b)
#вот это уже я делала кучу ошибок. Буду знать, что так низя
def complex(real, imag=0.0):#правильно \ неправильно : imag = 0.0
    return magic(r=real, i=imag)#                 r = real, i = imag
#не испольовать пробелы вокруг =, если оно для обоначения по умолчанию
#не использовать составные инструкции, ясно, спрашивала об этом как раз
if foo == 'blah':#правильно           if foo == 'blah': do_blah_thing()
    do_blah_thing()#  \ неправильно:  do_one(); do_two(); do_three()
do_one()#иногда можно писать тело циклов while, for или ветку if в той
do_two()#же строке, если команда короткая, но если команд несколько,
#никогда так не писать, а также избегать длинных строк.
#комментарии, противоречащие коду хуже, чем отсутствие комментариев,
#всегда исправлять комментарии, если меняется код; Ё-моё.  Всё не буду
#переписывать, но учту на будущее.  Комментарии должны являться закон-
#ченными предложениями, первое слово с большой буквы (если это не имя
#переменной, что имеет начало с маленькой[никогда не менять регистр
#переменной]).  Если комментарий короткий - можно опустить точку в
#конце предложения.  Блок комментариев обычно выходит из одного или
#более абзацев, составленных из предложений, каждое из которых должно
#оканчиваться точкой.  После точки в конце предложения ставить два
#пробела.  Писать комментарии на английском языке, если код будут читать
#люди не владеющие русским.
#Мдя.  Жизнь будто бы перевернулась, все эти десять дней занятий кажутся
#теперь чем-то неправильным.  Столько я наошибалась с комментами.  Ну да
#ладно, благо, что не для публичного чтения.  Ты то меня простишь за мои
#ошибки.  Мы чё, с тобой будем на английском комменты друг другу писать?
#Я думаю, можно завести такую практику потом, когда у меня будет меньше
#банальных вопросов к тебе возникать, иначе мои занятия удлиннятся в 2
#раза.
#Блок комментариев обычно объясняет код (весь или часть), идущий после
#блока, должен иметь тот же отступ, что и сам код. Каждая строчка должна
# начинаться с решёточки и одного пробела (sic!) после него, если только
# сам текст комментария не имеет отступа. Ё моё. Абзацы внутри блока
# комментариев разделяются пустой строкой с решёточкой.
#
# Стараться реже использовать встрочные комментарии :(  Отделяться они
# должны по крайней мере двумя пробелами от инструкции.  О, боже как я
# раньше жила...  После двух пробелов ставится решёточка и пробел после
# неё.  Чё такое "инструкция"?
#
# Комментарии в строке с кодом не нужны и отвлекают. Пипец мне придётся
# романы строчить...  Впрочем, если они очень полезны можно ставить так:
x = x + 1                       # Какая-то очень важная херня, точная
# Документация - чё  это?
# Писать документацию для всех публичных модулей, функций, классов,
# методов.  Строки документации необязательны для приватных методов,
# но лучше написать, что делает метод.  Комментарий нужно писать после
# строки с def.  Закрывающие ковычки должны стоять на отдельной строке.
# И лучше, если перед ними будет ещё и пустая строка:
"""Return a foobang

Optional plotz says to frobnicate  the bizbaz first.

"""   # Для однострочной документации можно ставить кавычки в строке.
#Контроль версий: если надо использовать Subversion, CVS, RCS в кодах:
__version__ = "$Revision: la40d4eaa0b $"    # Чёйта ?
# $Sourse$  Вставить эти строки после документации, перед кодом и
# отделять их одной пустой строкой до и после.
#
# Имена, которые видны пользователям как часть общественного API должны
# следовать конвенциям, что отражают использование, а не реализацию.
#
# Стили имён: b, B, lowercase, lower_case_with_underscores, UPPERCASE,
# UPPERCASE_WITH_UNDEESCORES, CapitalizedWords, mixedCase(1 lower),
# Capitalized_Words_With_Underscores.  Также существует стиль, в котором
# имена, принадлежащие одной логической группе, имеют один префикс:
# Например, st_mode, st_size, st_mtime.  Ещё используют дополнительно:
# _single_leading_underscore (индикатор, что имя для внутренних нужд),
# single_trailing_underscore_ (используется по соглашению  для избежания
# конфликтов с ключевыми словами языка python, например:
Tkinter.Toplevel(master, class_='ClassName')  # ),
# __double_leading_underscore (изменяет имя атрибута класса, то есть в
# классе FooBar поле __boo становится _FooBar__boo),   - не поняла..
# __double_leading_and_trailing_underscore__ (магические методы или
# атрибуты, которые находятся в пространствах имён, управляемых
# пользователем.  Например, __init__, __import__ или __file__.  Не
# изобретать такие имена и использовать только так, как написано)
#
# Избегать имён: l(латинская маленькая эль), O(заглавная латинская о),
# I(заглавная латинская ай) как однобуквенные идентификаторы.
#
# Имена модулей (запарилась, модули это что такое?): короткие имена из
# маленьких букв, можно подчёркивания (пакеты без подчёркивания[Что
# такое пакеты?]).  Когда модули на С/С++ имеет Pyyhon модуль, то тогда
# модуль начинается с символа подчёркивания.
#
# Имена классов: должны следовать соглаению CapWords (чё это?) ; могут
# использоваться соглашения для именования функций, если интерфейс
# документирован и используется в основном как функции.  Что такое
# "Соглашения об именах"?  Исключения являются классами.  Однако можно
# добавить в конце Error, если исключение является ошибкой.
#
# Имена глобальных переменных: то же, что и функции.  Добавлять в модули
# с помощью from M import *, механизм __all__, чтобы предотвратить
# экспортирование глобальных переменных.  Или использовать подчёркивание
# перед именами тех глобальных переменных, что используются только
# внутри модуля.
#
# Имена функций: должны состоять из маленьких букв, а слова разделяться
# символами подчёркивания. mixedCase допускается, где уже преобладает
# такой стиль.
#
# Аргументы функций и методов: всегда использовать self в качестве
# первого аргумента метода экземпляра объекта (это что за такое?); cls
# в качестве первого аргумента метода класса.  Если имя аргумента
# конфликтует с зарезервированным ключевым словом Python, добавить в
# конец имени символ подчёркивания.
#
# Имена методов и переменных экземпляров классов: тот же стиль, что и
# для имён функций; использовать один символ подчёркивания перед именем
# для непубличных методов и атрибутов.  Чтобы избежать конфликтов имёт с
# подклассами, использовать два ведущих подчёркивания.  Python искажает
# такие имена, пример - если класс Foo имеет атрибут с именем __a, он не
# может быть доступен как Foo.__a (доступ можно получить Foo._Foo__a).
# Два ведущих подчёркивания должны использоваться только для того, чтобы
# избежать конфликтов имён с атрибутами классов, предназначенных для
# наследования.  Что такое "наследование"?
#
# Имена констант: объявляются на уровне модуля и записываются только
# заглавными буквами, а слова разделяются подчёркиванием: MAX_OVERFKOW.
#
# Проектирование наследования.  Решить, какой должен быть метод класса
# или экземпляра класса (атрибут) - публичный или непубличный. Если есть
# сомнения - выбрать непубличный - его легче переделать в публичный, чем
# наоборот.  Публичные атрибуты - это те, которые будут использовать
# программисты, быть уверенной в отсутствии обратной несовместимости -
# это что такое?  Непубличные атрибуты не предназначены третьим лицам,
# поэтому можно не гарантировать, что не изменить или не удалить их.
# Другой тип атрибутов классов - API подклассы (protected).  Некоторые
# классы проектируются так, чтобы от них наследовали другие классы,
# которые расширяют или модифицируют поведение базового класса.  Когда
# проектируется такой класс, решить и указать, какие атрибуты публичны,
# какие принадлежать API, какие используются базовым классом.
#
# Открытые атрибуты не  должны иметь в начале имени подчёркивания.  Если
# имя открытого атрибута конфликтует с ключевым словом языка, добавить в
# конец имени один символ подчёркивания.  Называть простые публичные
# атрибуты понятными именами и не писать сложных методов доступи и
# изменения (accessor/mutator, get/set).  Их можно добавить потом, если
# потребуется.  В этом случае использовать свойства(properties), чтобы
# скрыть функциональную реализацию за синтаксисом доступа к атрибутам.
# [properties работают только в классах нового стиля - все в python 3]
# [стараться избавиться от побочных эффектов]
# [избегать использования вычислительно затратных операций, потому что
# из-за записи с помощью атрибутов создаётся впечатление, что доступ
# происходит относительно быстро]
# [если класс, чтобы от него наследовались другие классы, но не хочу,
# чтобы подклассы унаследовали некоторые атрибуты - добавить в имена
# два символа подчёркивания в начало и ни одного в конец.  Механизм
# изменения имён в python сработает так, что имя класса добавится к
# имени такого атрибута, что позволит избежать конфликта имён с
# атрибутами подклассов]
# [если подкласс будет иметь то же имя класса и имя атрибута, то вновь
# возникает конфликт имён]
# [механизм изменения имён может затруднить отладку или работу с
# __getattr__(), однако он документирован и реализуется вручную]
# [стараться достичь компромисса между необходимостью избежать конфликта
# имён и возможностью доступа к этим атрибутам]
#! (это всё не понимаю) !
#
#
# ОБЩИЕ РЕКОМЕНДАЦИИ
#
# Код должен быть написан так, чтобы не зависеть от разных реализаций
# языка.  В критичных к времени выполнения частях программы использовать
# ".join() - эт чё, и обязательна ковычка ? - склеивание строк будет
# выполнено за линейное время независимо от реализации.
#
# Сравнения с None должны выполняться с использованием оператором is или
# is not, а не с помощью операторов сравнения.  Не писать if x, если
# имеется в виду if x is not None - если, к примеру, при тестировании
# такая переменная может принять значение другого типа, отличного от
# None, но при приведении типов может получиться False.
#
# При реализации методов сравннения, лчуше всего реализовать все шесть
# операций сравнения (__eq__, __ne__, __lt__, __le__, __gt__, __ge__),
# [эт чё такое?] чем полагаться на то, что другие программисты будут
# использовать только конкретный вид сравнения. Декоратор:
functools.total_ordering()  # для реализации недостающих методов.
#
# Интерпретатор может поменять y > x на x < y , y >= x на x <= y, может
# поменять местами аргументы x == y и x != y.  Гарантируется, что
# операции sort() и min() используют оператор <, а max() использует
# оператор >.  Однако лучше осуществить все шесть операций, чтобы не
# возникало путаницы в других местах.
#
# Использовать def, а не присваивание лямбда-выражения к имени:
def f(x): return 2*x  # правильно     f = lambda x: 2*x   - неправильно
#
# Наследовать класс исключения от Exception, а не от BaseException.
# Прямое наследование от BaseException зарезервировано для исключений,
# которые не следует прехватывать.
#
# Использовать цепочки исключений соответствующим образом.  В pyyhon 3
# raise X from Y следует использовать для указания явной замены без
# потери отладочной информации.  Когда намеренно заменяется исключение
# raise X from None, следить, чтобы соответствующая информация перешла
# в новое исключение (такие, как сохранение имени атрибута при
# преобразовании KeyError в AttributeError или вложение текста исходного
# исключения в новаом)
#
# Когда генерируется ислючение писать:
raise ValueError('message')
#
# Когда код перехватывает исключения, перехватывать конкретные ошибки
try:
    import platform_specific_module
except ImportError:
    platform_specific_module = None
# вместо простое выражение "except:" также перехватит и SystemExit, и
# KeyboardInterrupt, что породит проблемы.  Если надо перехватить все:
except Exception:
# "except:" надо использовать когда: 1) если обработчик выводит всё о
# случившейся ощибке, пользователь будет знать, что произошла ошибка; 2)
# Если нужно выполнить некоторый код после перехвата исключения, а потом
# бросить для обработки в другом месте.  Альтернатива "try...finaly".
#
# При связывании прехваченных исключений предпочитать явную привязку:
try:
    process_data()
except Exception as exc:
    raise DataProcessingFailedError(str(exc))
# Такой синтаксис позволяет избежать проблем неоднозначности.
#
# При перехвате ошибок операционной системы использовать явную иерархию
# исключений, аместо анализа значений errno.
#
# Стараться заключать в каждую констркуцию try...except минимум кода,
# чтобы легче отлавливать ошибки. Позволяет избежать замаскированных
# ошибок, правильно:
try:  #                           try:
    value = collection[key]  #    return handle_value(collection[key])
except KeyError:  #               except KeyError:
    return key_not_found(key)  #  return key_not_found(key)
else:  # 1) много действий ; 2) перехватится KeyError, который может
    return handle_value(value)  # сгенерировать handle_value()
#
# Когда ресурс является локальным на участке кода, использовать with для
# того, чтобы после выполнения он был очищен оперативно и надёжно.
#
# Менеджеры контекста следует вызывать с помощью отдельной функции или
# метода, всякий раз, когда они делают что-то другое, чем получение и
# освобождение ресурсов.  Например:
with conn.begin_transaction():    # неправильно = with conn
    do_stuff_in_transaction(conn)  # не даёт инфы по __enter__ __exit__
#
# Использовать строковые методы вместо модуля string.  Они быстрее и
# имеют тот же API для unicode.
#
# Пользовать ".startswith() и ".endswith() вместо обработки срезов строк
# для проверки суффиксов или префиксов.  Меньше ошибок и чище.  Например
if foo.startswith('bar'):     # неправильно   if foo[:3] == 'bar':
#
# Сравнение типов объектов делать с помощью isinstancs(), а не типов:
if isinstance(obj, int):  # неправильно: if type(obj) is type(1):
#
# Для последовательностей использовать факт, что пустая = False:
if not  seq:  # неправильно:    if len(seq)
if seq        #                 if not len(seq)
#
# Не пользоваться строковыми константами, которые имеют важные пробелы в
# конце - они невидимы, а многие редакторы обрезают их.
# 
# Не сравнивать логические типы с True \ False с помощью == :
if greeting:      # неправильно   if greeting == True (или is True):
#
#
# Многое не поняла. Записала для практики, для пробы понимания и чтобы
# сразу было видно что неп онятно.  В последствии, видя знакомые штуки
# надеюсь припомнить их, так как уже записывала и думала об них.